day06回顾：
 列表：
  列表是可变的序列容器
 创建方法：
  1、字面值
  [][1,2,3][true...]
  2、构造函数
  list()   list(range(10))
  3、列表推导式（今天才学）
 列表的运算：
  +  +=  *  *=
 列表的比较运算：
  >  >=  <  <=  ==  !=
 列表的内容判断
 in  not in
 索引取值  V = L[0]
 索引赋值  L[0] = v
 切片取值  L2 = L[1:5]
 切片赋值  L[1:5] = L2

 方法：
  L.index(v,开始索引，结束索引)  #根据值返回索引
  L.insert(index,obj)         播放obj到Index之前
  L.count(x)                  返回x在L中的个数
  L.remove(x)                 把L中第一次出现的x删除
  L.copy()                    复制列表，浅拷贝
  L.append(x)                 向L末尾追加x
  L.extend(x)                 向L的末尾扩展x
  L.sort(reverse = false)     排序
  L.reverse()                 反转
  L.pop([index])              移除(或取出)


day07


列表和字符串比较
 列表和字符串都是序列，元素之间有先后顺序关系
 字符串是不可变的序列，列表是可变的序列
 字符串中每个元素只能存储字符，而列表可以存储任意类型的元素
 列表和字符串都是可迭代对象

字符串文本解析方法 split 和 join
 S.split(sep = None) 将字符串，使用sep作为分隔符拆分S字符串
                     返回拆分后的字符串列表，当不给定参数时，用空白字符进行拆分
 S.splitlines()      将字符串使用换行符'/n' 作为分隔符进行拆分
 S.join(iterable)    用可迭代对象中的字符串，返回合并后的字符串
 示例：
 s = 'beijing is capital'
 L = s.split()   #L = ['beijing','is','capital']
 s2 = '这是第一行\n这是第二行\n这是第三行‘
 L2 = s.splitlines()
 s3 = '#'.join(L)   #s3 = 'beijing#is#capital'

练习：
 有字符串'hello'，生成字符串‘hello'和'h-e-l-l-o'

列表推导式 list comprehension
 列表推导式是用可迭代对象创建列表的表达式
 作用：
  用简易方法创建列表
 语法：
  [表达式 for 变量  in  可迭代对象]
  或
  [表达式 for 变量  in  可迭代对象  if  真值表达式]
 说明：
  if  子句部分可以省略
 示例：
  # 生成一个数值为1～9平方的列表
  L = [x**2 for x in range(1,10)]

练习：
 1、用列表推导式生成1～100内奇数的平方的列表：
  结果是：[1,9,25,49...9801]

列表推导式的嵌套：
 语法：
  [表达式 
      for 变量1 in 可迭代对象1 if 真值表达式1
          for 变量2 in 可迭代对象2 if 真值表达式2
              ....
  ]
 示例：
 #  将列表[10,20,30]中的元素和列表[1,2,3]元素分别相加，
 #  将得到的数字放入一个列表中
 L = [x+y for x in [10,20,30] for y in [1,2,3]]
 print(L)  # [11,12,13,21,22,23,31,32,33]

练习：
 用字符串'ABC'和'123'生成如下列表：
 ['A1','A2','A3','B1','B2','B3','C1','C2','C3']

元组 tuple
 元组是不可改变的序列容器，同list一样，元组可以存入任意类型数据
 表示方法：
  用小括号()扩起来，单个元素括起来后加逗号，区分单个对象还是元组
 创建空元组的字面值
  t = ()  #()将创建空元组
 创建非空元组的字面值
  t = 200,
  t = (20,)
  t = (1,2,3)
  t = 100,200,300
 注：
  type(x)函数可以返回x的类型
 
元组创建的错误示例：
 t = (20)  #t 绑定20这个对象，不是元组
 x,y,z = 100,200,300   #序列赋值，不是元组
 x,y,z = (100,200,300) #序列赋值
 x,y,z = [100,200,300] #序列赋值
 x,y,z = 'ABC'         #序列赋值,不是元组

目前学习的序列：
 字符串 str
 列表   list 
 元组   tuple
 字节串  bytes
 字节数组bytearray

元组的构造函数 tuple
 tuple() 生成一个空的元组，等同于()
 tuple(iterable) 用可迭代对象生成一个元组
 示例：
  t = tuple()  #t绑定空元组  等同于 t = ()
  t = tuple(range(1,10,3)) # t = (1,4,7)
  t = tuple('ABC')  # t = ('A','B','C')

元组的运算：
 算数运算：
  +  +=  *  *=
  示例：
   t1 = (1,2,3) + (4,5,6)
   t1 += (7,8,9)
   t2 = (1,2) * 3
   t2 *= 2
 比较运算：
  <  <=  >  >=  ==  !=
  注：元组比较的规则与列表的比较规则完全相同
  示例：
   (1,2,3) < (1,2,4)  #true
   ('ABC',456) > ('123',789)  #true
   (1,'二) > ('二',1)  #出错
 in  和  not in  运算符：
 判断一个值是否存在与元组中，如果是返回true，否则返回false
 规则与列表的in 和not in 规则相同

 []运算符：
  索引 index
  用法等同于列表的索引
  元组不支持索引赋值操作
  切片 slice
  用法等同于列表的切片
  元组不支持切片赋值
  示例：
   x = (1,2,3,4,5,6)
   print(x[0])  #1
   print(x[1：2]) #(2,4,6)
 元组的方法：
  T.index(v[,begin[,end]])  返回对应元组的索引下标，当v不存在时，
                            触发ValueError错误
  T.count(x)   返回元组中对应元素的个数

序列相关的函数小结
 len(x)
 max(x)
 min(x)
 sum(x)
 any(x) 只要有一个为真，则返回真
 all(x) 所有都为真，才返回真
序列的构造函数：
 str(obj)  创建字符串
 list(iterable) 创建列表
 tuple(iterable) 创建元组
序列的反转函数(reverse)：
 reversed(可迭代对象),  返回反向顺序的可迭代对象
 示例：
  s = 'ABCD'
  for ch in reversed(s):
      print(ch)   # D C B A顺序打印
  L = list(reversed(s))  # L = ['D','C','B','A']

练习：
 任意输入一个字符串，将次字符串中的空格全部去掉，生成反转后的字符串
 如：请输入：abc  def  g
 生成如下字符串：
  s2 = 'gfedvba'
  print(s2)  #gfedvba
  提示：可以用reversed进行反转


字典　dict
什么是字典：
　字典是一种可变的容器，可以存储任意类型的数据
　字典中的每个数据都是用＂键＂(key)进行索引，而不像序列(字符串等)可以用整数下标进行索引．
　字典中的数据没有先后顺序关系，字典的存储是无序的
　字典中的数据以键－值(key-value)对的形式进行映射存储
　字典的键不能重复，且只能用不可变类型作为字典的键
字典的字面值创建方法：
　字典的表示方式是以{}括起来的，以冒号（：）分隔键－值对，各键值对之间用逗号分隔开
创建空字典：
　d = {}
创建非空的字典：
　d = {'name':'小明','age':30}
不可变类型：
　Bool,int ,float, complex, str, tuple, frozenset(固定集合),
  bytes(字节数组)
可变数据类型：
　list, dict,set(集合),bytearray(字节数组)
创建字典示例：
　
字典的构造函数　dict：
　dict()  创建一个空的字典，等同于｛｝
　dict(iterable)  用可迭代对象的数据创建一个字典
　（＊＊kwargs)    用关键字传参方式创建一个字典
示例：　
　d = dict()
  L = [(1,2),[3,4],'AB')]
  d = dict(L)
  d = dict(name='tarena',age=17)

字典的基本操作：
　字典的键索引：
　　用［］运算符可以获取字典内＂键所对应的＇值＇．
　语法：
　　v　＝　字典[键]
　示例：
　　d = {'name':'tarena','age':17}
   print(d['name'],'它的年龄是＇，d['age']:17)

添加和修改词典的键值对
　语法：　
　　子典[键]　＝　表达式
　说明：
　　键不存在，创建键，并绑定键对应的值；键存在，修改键绑定的值．

del 语句用来删除字典的键值对
　语法：
　　　del 字典[键]
　示例：
　　　d = {'name':'tarena','age':17}
     del d['name']
     del d['age']

字典的成员资格判断　in 和 not in 运算符：
　in 用来判断一个键是否存在于字典中，如果存在则返回true,否则返回false
  not in 的返回值与　in　相反
　示例：
　　d = {'name':'tarena','age':16}
   'name' in d  #true
   16 in d #运算符只判断键，不判断数值
   'name' not in d #false
   100 not in d #true
练习：
　写程序，实现以下需求：
　1)将如下数据形成一个字典seasons
  ‘键'　　　　　　　　　　’值‘
  １　　　　　－－－－－>'春季有１，２，３月’
  ２　　　　　－－－－－>'夏季有４，５，６月‘
  ３　　　　　－－－－－>'秋季有７，８，９月’
  ４　　　　　－－－－－>'冬季有10,11,12月’
 2、让用户输入一个整数代表这季度，打印这个季度的信息，
 　　如果用户输入的信息不存在与字典中，则打印信息不存在

字典的迭代访问
　字典是可迭代对象，字典只能对键进行迭代访问
　示例：
　d = {'姓名':'小张','年龄':20}
  for k in d:
      print('键:',k,'值',d[k])

字典的比较运算：
　＝＝　　！＝
　＝＝　判断字典是否完全相同（键相同，值也相同返回true)
　！＝　判断字典是否不同（与　＝＝相反）

可以用于字典的内建函数
　len(x)  返回字典键值对的个数
　max(x)　返回字典键的最大值
　min(x)　返回字典键的最小值
　sum(x)　返回字典中所有键的和
　any(x)　真值测试，如果字典中其中一个键为真值则返回真
　all(x)　真值测试，字典中所有键都为真，才返回真

字典的字面值创建方法：参见文档
示例：
d = {1:'壹，２：'贰’，10:'拾'.5:'五'}
for k in d:
    print(k)  #1  2  10  5  
for k in d.keys():
    print(k)  #1  2  10  5
for v in d.values():
    print(v)  #’壹‘　　’贰‘　　’拾‘　　’五‘
for t in d.items():
    print(t)  #　d的键值对
for k,v in d.items():
    print('键:',k,'值:',v)
练习：
　输入一行字符串，打印出这个字符串中出现过的字符及出现过的次数
　如：请输入：ＡＢＣＤＡＢＣＡＢＡ
　打印：
 A:4次
 B:3
 D:1
 C:2
 注：不要求打印的顺序

字典推导式
　字典推导式是用可迭代对象依次生成字典内元素的表达式
　语法：
{键表达式：值表达式　for 变量　in 可迭代对象　[if 真值表达式]}
注：[]代表内部的内容可省略
示例：
　＃　生成一个字典，键为１～９的整数，值为键的平方
　d = {x: x**2 for x in range(10)}
练习：
　有字符串列表如下：
　　L =　['tarena','xiaozhang','hello']
 用上述列表生成如下字典：
 　d = {'tarena':6,'xiaozhang':9,'hello':6}
  注：字典的值为键的长度

字典推导式的嵌套
　语法同列表推导式的嵌套规则一致（略）

练习：
　１、输入一些单词和解释，将单词作为键，将解释作为值，将这些数据存入到字典中，
　　　打印这个字典
　　　然后，循环　输入要查询的单词，给出单词相关的解释，如果字典中不存在这些词
　　　则显示查无此词
　２、已知有两个等长度的列表：
　　list = [1001,1003,1008,1006]
　　list = ['Tom','Jerry','Spike','Tyke']
  生成如下字典：
  　{'Tom':1001,'Jerry':1003,'Spike':1008,'Tyke':1006}