一．动机
1.文本处理已经成为计算机的常见工作
2.对文本内容的搜索，定位，提取逻辑比较复杂
3.为了快捷方便的解决上述问题，产生了正则表达式

二．简介
定义：即文本的高级匹配模式，提供搜索，替换，查找等功能．其本质是一系列由字符和特殊符号构成的字串，这个字串即正则表达式．
匹配原理：通过普通字符和有特定含义的字符来组成字符串，用以描述一定的字符串规则，比如重复，位置等，来表达一类特定的字符串内容．　

三．元字符的使用
１.普通字符
    匹配规则：每个普通字符匹配对应的字符
    re.findall('ab','abcdasjb')
    Out[2]: ['ab']

    注意：＊正则表达式永远是作为一个规则整体匹配
         ＊python中正则表达式可以匹配中文

２.或
    元字符：　｜
    匹配规则：匹配　｜　两侧任意一个正则规则即可
    In [3]: re.findall('ab|cd','abcdasabcjb')
    Out[3]: ['ab', 'cd', 'ab']

３.匹配开始位置
    元字符：　＾
    匹配规则：使用＾规定目标字符串开头位置
    re.findall('^Hello','Hello world')
    Out[6]: ['Hello']

４.匹配结尾位置
    元字符：　$
    匹配规则：使用$匹配目标字符串结尾位置
    In [10]: re.findall('Jame$','Hi,Jame')
    Out[10]: ['Jame']
    注意：正则表达式中，如果有$^必然出现在正则表达式的开始和最后．如果同时有＾$则正则必须匹配目标字符串全部内容．

５.匹配任意字符
    元字符：　．
    匹配规则：匹配除　换行　外的任意一个字符
    In [11]: re.findall('小.','小红说小王欺负小李')
    Out[11]: ['小红', '小王', '小李']

    In [12]: re.findall('.','小红说小王欺负小李')
    Out[12]: ['小', '红', '说', '小', '王', '欺', '负', '小', '李']

６.匹配字符集中的字符
    元字符：[字符集]
    匹配规则：匹配字符集中任意一个字符
    表达形式：[#abc好坏]－－＞匹配[]内任意一个字符
            [0-9][a-z][A-Z]-->匹配区间内的任意一个字符
            [-_#0-9a-z]-->混合书写，区间写在后面
    In [16]: re.findall('[_a-z0-9]','南京 1937')
    Out[16]: ['1', '9', '3', '7']

    In [17]: re.findall('[_a-z0-9]','南京 1937 clude')
    Out[17]: ['1', '9', '3', '7', 'c', 'l', 'u', 'd', 'e']

７.匹配字符集反集
    元字符：[^...]
    匹配规则：匹配除了字符集中的任意一个字符
    In [23]: re.findall('^[^a-z0-9]..','南京 1937 clude')
    Out[23]: ['南京 ']

    In [24]: re.findall('^[^_a-z0-9]..','Hi,Jame')
    Out[24]: ['Hi,']

８.匹配重复
    元字符：　＊
    匹配规则：匹配前面的字符出现０次或多次
    In [25]: re.findall('ab*','abcdasabbbbcajb')
    Out[25]: ['ab', 'a', 'abbbb', 'a']

    注意：ab*当表达b出现０次时是 a 而不是　ab

９.匹配重复
    元字符：　＋
    匹配规则：匹配前面的字符出现１次或多次
    In [27]: re.findall('ab+','abcdasabbbbcajb')
    Out[27]: ['ab', 'abbbb']

    In [34]: re.findall('[A-Z][a-z]+','How are you,Jame')
    Out[34]: ['How', 'Jame']

10.匹配重复
    元字符：　？
    匹配规则：匹配前面的字符出现０次或１次
    In [36]: re.findall('ab?','abcdassssabbbbcajb')
    Out[36]: ['ab', 'a', 'ab', 'a']

11.匹配重复
    元字符：　｛n｝
    匹配规则：匹配前面的字符出现n次
    In [37]: re.findall('[0-9]{11}','15100311189')
    Out[37]: ['15100311189']

12.匹配重复
    元字符：　｛m,n｝
    匹配规则：匹配前面的字符出现m-->n次


13.匹配任意(非)数字字符
    元字符：　＼d　　＼D
    匹配规则：\d 匹配任意普通字符［0-9］
            \D 匹配任意非普通字符［0-9］
    In [39]: re.findall('1\d{10}','15100311189')
    Out[39]: ['15100311189']

    In [41]: re.findall('\D*','代号  007')
    Out[41]: ['代号  ', '', '', '', '']

    In [42]: re.findall('\D+','代号  007')
    Out[42]: ['代号  ']

14.匹配任意(非)普通字符
    元字符：　＼w  \W
    匹配规则：＼w 匹配任意普通字符
            \W　匹配任意非普通字符
    说明：普通字符指数字字母下划线(汉字也是普通字符)
    In [43]: re.findall('\w+','Port 27017 App#mongodb')
    Out[43]: ['Port', '27017', 'App', 'mongodb']

    In [44]: re.findall('\W+','Port 27017 App#mongodb')
    Out[44]: [' ', ' ', '#']

15.匹配(非)空字符
    元字符：　＼s  \S
    匹配规则：　＼s 匹配任意空字符
    　　      ＼S 匹配任意非空字符
    说明：空字符指　空格　\r \n \t \v \f
    In [47]: re.findall('\w+\s+\w+','hello  word')
    Out[47]: ['hello  word']

16.匹配开头结尾位置
    元字符：　\A  \Z
    匹配规则：　\A 匹配字符串开头位置
            \Z 匹配字符串结尾位置

17.匹配(非)单词边界
    元字符：　\b \B
    匹配规则：＼b 匹配单词边界位置
            \B　匹配非单词边界位置
    说明：数字，字母，下划线，(汉字)，和其他字符的交界为单词边界
    In [57]: re.findall(r'\Bis\b','This is a test')
    Out[57]: ['is']

总结：
匹配单个字符：．　［．．．］　［＾．．．］ \d  \D  \w  \W  \s  \S
匹配重复: * + ? {n} {m,n}
匹配位置: ^ $  \A  \Z  \b  \B
其他: |  ()  \


四．正则表达式转义
１．特殊字符　：. * $ + ? {} [] () | \  ^
２．当正则表达式需要匹配特殊字符的时候，需要加转义．
    In [65]: re.findall('\$\d+','月薪$8000')
    Out[65]: ['$8000']
３．raw 字符串
字符串　　　    　正则　      　　　目标
＂\\$\\d+＂-->\$\d+---->$8000


五．贪婪　和　非贪婪
１．贪婪模式：正则表达式的重复匹配总是尽可能向后匹配更多的内容，比如：＊　　＋　　？　｛m,n｝
２．非贪婪：满足重复条件即可，不向后匹配更多内容
贪婪--->非贪婪：　*?  +?  ??  {m+n}?
In [75]: re.findall(r'a.+?b','allowb  avb  asdsaldb')
Out[75]: ['allowb', 'avb', 'asdsaldb']

六．正则表达式分组
定义：使用（）可以为正则表达式建立内部分组，子组则是正则表达式的一个内部整体．
作用：
１．可以作为内部整体操作，改变元字符的操作对象
２．匹配到内容时，子组对应部分可以单独提取

１．捕获组(有名字的子组)
    命名格式：(?P<name>pattern)
    In [84]: re.search(r'(?P<pig>ab)cdef','abcdef').group()
    Out[84]: 'abcdef'

子组注意事项：
－一个正则表达式中可以有多个子组
－子组不要重叠或者过多嵌套
－子组不会影响正则整体匹配的原则

七．正则表达式匹配原则
１．正确性．能够正确的匹配出目标字符串内容
２．排他性．除了目标内容，尽可能不会匹配到其他内容
３．全面性．尽可能做到对目标字符串考虑全面，不遗漏

八．python re 模块
regex = compile(pattern,flags = 0)
功能：生成正则表达式对象
参数：pattern  正则表达式
    flags     功能标识位，扩展正则表达式功能
返回值：正则表达式对象

re.findall(pattern,string,flags = 0)
功能：使用正则表达式匹配目标字符串
参数：pattern 正则
    string　　目标字符串
返回值：匹配内容列表，如果正则表达式有子组则只得到子组对应内容

regex.findall(string,pos,endpos)
功能：使用正则表达式匹配目标字符串
参数：string　　目标字符串
    pos    设置匹配目标字符串开始位置
    endpos 设置匹配目标字符串结束位置
返回值：匹配内容列表，如果正则表达式有子组则只得到子组对应内容

re.split(pattern,string,flags = 0)
功能：使用正则表达式匹配内容切割字符串
参数：pattern 正则
    string　　目标字符串
返回值：切割后的内容列表

re.sub(pattern,replace,string,max,flags)
功能：使用指定字符串替换正则匹配到的内容
参数：pattern 正则
    replace 指定字符串
    string　　目标字符串
    max     最多匹配几处
返回值：替换后的字符串

re.subn(pattern,replace,string,max,flags)
功能：,同sub用法，使用指定字符串替换正则匹配到的内容
参数：pattern 正则
    replace 指定字符串
    string　　目标字符串
    max     最多匹配几处
返回值：替换后的字符串，多添加了一个替换个数n

----=====-----+++++------******----------=====-----+++++------******------

re.finditer(pattern,string,flags)
功能：使用正则表达式匹配目标内容
参数：pattern 正则
    string　　目标字符串
返回值：匹配结果的迭代对象

re.fullmatch(pattern,string,flags)
功能：使用正则表达式完全匹配目标字符串
参数：pattern 正则
    string　　目标字符串
返回值：匹配结果的match对象

re.match(pattern,string,flags)
功能：使用正则表达式匹配目标字符串开头
参数：pattern 正则
    string　　目标字符串
返回值：匹配结果的match对象

re.search(pattern,string,flags)
功能：使用正则表达式匹配目标字符串第一处匹配内容
参数：pattern 正则
    string　　目标字符串
返回值：匹配结果的match对象

----=====-----+++++------******----------=====-----+++++------******------
regex对象属性变量
flags:标识位值
pattern:正则表达式
groups:子组数量
groupindex:捕获组名和组序号组成的字典
----=====-----+++++------******----------=====-----+++++------******------

２．match对象的属性和方法
[1]
属性变量
pos：起始位置
endpos：终止位置
re：正则表达式
string：目标字符串
lastgroup：最后一组祖名
lastindex：最后一组序号

[2]
属性方法
span():获取匹配内容的起至位置
start():获取匹配内容的开始位置
end():获取匹配内容的终止位置
groups():获取每个子组对应的内容
groupdict():获取捕获组字典，组名为键，对应内容为值
group(n=0):
功能：获取match对象对应的内容
参数：数字表示获取相应的子组匹配内容，默认表示全部匹配内容
    子组名称表示获取对应捕获组匹配内容
返回值：匹配的字符串


----=====-----+++++------******----------=====-----+++++------******------
flags 参数扩展



３．常用标识位
A == ASCII 元字符只能匹配ascii字符
I == IGNORECASE 匹配时忽略字母的大小写
S == DOTALL  使.可以匹配换行
M == MULTILINE 使　^ $　可以匹配每一行的开头结尾位置
X == VERBOSE 为正则添加每行注释

４．使用多个flag
方法：使用按位或操作
e.g. flags = re.I | re.M