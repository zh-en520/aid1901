一．通信模型分类
１．循环服务器模型：
　　循环接收客户端请求，处理请求．同一时刻只能处理一个请求，处理完毕后再处理下一个．
　　优点：实现简单，占用资源少
　　缺点：无法同时处理多个客户端请求
　　适用情况：访问量少，处理的任务可以很快完成，客户端无需长期占用服务器．udp比tcp更适合循环．

２．IO并发模型：
　　利用IO多路复用等技术，同时处理多个客户端IO请求．
　　优点：资源消耗少，可以同时处理多个IO，效率较高．
　　缺点：只能处理IO行为，无法处理cpu运算．
　　适用情况：HTTP请求，网络传输等都是IO行为，可以充分利用iO多路复用．

３．多进程／线程并发：
　　当一个客户端连接服务器，就创建一个新的进程／线程为客户端服务，客户端退出时再销毁该进程／线程．
　　优点：能够满足客户端长期占用服务器，处理各种请求．
　　缺点：消耗资源较大，对服务器压力较大
　　适用情况：客户端同时连接数不会太多，且客户端处理任务复杂需要长期占有服务端时比较合适．

二．实现：
１．多进程网络并发
  [1] 基于fork的多进程并发
  1.创建监听套接字
  2.等待客户端请求
  3.客户端连接后创建新的进程处理客户端请求内容
  4.原进程继续等待其他客户端连接
  5.如果客户端退出则销毁对应进程
  示例：fork_server.py

三．ftp文件服务器
１．功能
  [1] 分为服务端和客户端，要求可以有多个客户端同时操作
  [2] 客户端可以查看服务端文件库中的文件
  [3] 客户端可以从文件库中下载文件到本地
  [4] 客户端可以将本地文件上传到服务端文件库
  [5] 使用print在客户端打印一定的命令提示界面，引导操作

２．技术分析
  [1] fork多进程并发模型
  [2] tcp套接字
  [3] 只查看普通文件，不差看隐藏文件或文件夹，
  　　　获取文件列表：os.listdir()
　　　　判断文件类型：os.path.isfile()

３．结构设计
　[1] 网络搭建使用函数封装
　[2] 将文件操作功能封装在类中

４．具体功能分析
  [1] 网络搭建

  [2] 查看文件列表
  [3] 下载文件
  [4] 上传文件
      *客户端发起请求
      *服务端接收请求后给客户端返回确认信息
      *客户端和服务端进行数据传输
  [5] 客户端退出

四．实现
１．基于threading的多线程并发
  －每当一个客户端连接，就创建一个线程处理客户端请求，主线程循环等待其他客户端请求．客户端退出则对应线程结束．

２．实现步骤
  －创建监听套接字
  －循环接收客户端连接
  －有新的客户端连接，创建线程处理客户端请求
  －主线程继续等待其他客户端连接
  －客户端退出则对应分支线程退出

五．集成模块完成进程/线程网络并发
１．使用方法
  import socketserver
  *通过模块提供的不同类的组合完成多进程或者多线程，tcp或者udp的并发模型．

３．使用步骤
  －创建服务器类，通过选择继承的类，决定创建TCP和UDP，多进程或者多线程并发模型．
  －创建请求处理类，根据服务器类型，选择stream还是datagram处理类．重写handle方法，做具体的请求处理．
  －通过服务器类实例化对象，绑定请求处理类．
  －通过服务器对象启动服务．

六．HTTPSERVER v2.0
１．主要功能
  －接收客户端(浏览器)http请求
  －解析客户端发送的请求
  －根据请求组织数据内容
  －将内容以http响应的格式发送浏览器

２．升级点
  －采用多线程并发，可以满足多个客户端同时发起请求
  －做基本的请求解析，根据不同的请求内容，返回具体网页
  －如果用户访问非网页，则做一些简单处理
  －通过类将httpserver的功能进行封装

３．技术点
  －tcp多线程并发模型
  －http协议请求和响应的结构
  　请求行：GET  /abc.html  HTTP/1.1
  　响应头：HTTP/1.1  200  OK
          响应体
  －类的设计
  　使用：考虑：
  　用户如何用这个类？
    －httpd = HTTPServer()
    －hrrpd.serve_forever()
  　用户需要自己确定什么内容？
    －服务器地址

