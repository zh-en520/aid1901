
一．多任务编程

１．意义：充分利用计算机多核资源，同时运行多个任务，提高程序执行效率．

２．实现方案：多进程，多线程．

３．并行：多个任务利用计算机多个资源在同时执行，多个任务间为并行关系．
　　并发：多个任务都被接收，但是内核在任务间不断切换，达到了好像多个任务都被处理的结果，
　　　　　实际每一时刻只有一个任务占用内核．

二．进程（process）
1.定义：程序在计算机中的一次执行过程
　＊程序是一个可执行文件，是静态的，占有磁盘空间
　＊进程是一个动态执行过程，占有计算机运行资源，有一定的生命周期．

２．如何产生一个进程
　　[1] 用户空间通过调用程序或者特定接口发起进程创建
　　[2] 操作系统接收用户请求，开始创建进程
　　[3] 操作系统调配计算机资源，确定进程状态等
　　[4] 操作系统将创建的进程提供给用户使用

3.进程概念
　　[1] cpu时间片：如果一个进程占有cpu内核，则称这个进程占有cpu时间片．
　　[2] PCB(进程控制块)：在内存中开辟出一块空间，用于存放进程的基本信息，也用于系统对进程的识别．
　　[3] 进程ID(PID)：系统为每个进程分配一个大于０的整数作为ID，所有进程ID不会重复．
　　　　linux命令查看PID: ps -aux
　　[4] 父子进程：系统中每一个进程（除了初始进程）都有唯一的父进程，可以有０个或多个子进程，父子进程便于系统对进程的管理．
　　　　查看进程数：pstree
　　　　查看父子进程PID:ps  -ajx
　　　　parent process
　　[5] 进程状态
    三态：就绪态：进程具备执行条件，等待分配cpu资源
        运行态：进程占有cpu 时间片，正在运行
        等待区：进程暂停执行，让出cpu
    五态(增加新建和终止)：
        新建态：创建进程获取资源的过程
        终止态：进程结束，释放资源的过程
    ＳＴＡＴ列标志
    ＊第一个字母表示进程状态
    Ｓ　等待态
    Ｄ　等待态
    Ｔ　等待态
    Ｒ　运行态
    Ｚ　僵尸
    ＊后面的标志表示进程特征
    ＜ 优先级较高
    Ｎ　优先级较低
    ＋　前台进程
    s　会话组长
    1　有多线程

４．进程运行特征
　　[1] 进程可以使用计算机多核资源
　　[2] 进程是计算机分配资源的最小单位
　　[2] 进程之间运行互不影响，各自独立
　　[2] 每个进程空间独立，各有使用各自空间内容

面试要求：
１．什么是进程
　　进程有什么特点
２．进程有哪些状态，状态之间如何转换


三．基于fork的多进程编程

import os

pid = os.fork()
功能：创建新的进程，没有参数
返回值：整数，如果创建进程失败，返回负数，成功则原有进程返回新进程的ＰＩＤ号，新进程得到０.?????

什么时候创建的子进程，怎么创建的？
父进程为什么会返回子进程的Pid号
子进程和父进程在实际意义上的作用
作业：
１．对要求问题进行总结回答
２．整理IO多路复用方法，要求能写出select
３．复习，类的使用(__init__,super继承，属性特殊)

四．基于fork的多进程编程（序）
1.fork的运行特征
　示例间：forkday5.py
　＊子进程会复制父进程的全部内存空间，从fork的下一句开始执行；
　＊父子进程各自独立运行，执行顺序不确定；
　＊通常情况下，fork和if结构是固定搭配，利用父子进程中fork的返回值差异
　　使其各自执行不同的内容．
　＊父进程在fork之前开辟的内存空间子进程同样会拥有，父子进程各自对各自空间的操作互不影响．
　＊父子进程有各自的特征，比如PID   PCB命令集．


五．进程相关函数
１．os.getpid()
  功能：获取当前进程的ＰＩＤ号
  返回值：返回PID
２．os.getppid()
  功能：获取父进程的PID号
  返回值：返回PID
３．os._exit(status)
  功能：结束一个进程
  参数：进程的退出状态　整数，可以进行约定，比如０代表异常退出，１代表正常退出，负数代表退出失败
４．sys.exit([status])
  功能：结束一个进程
  参数：整数表示进程退出状态　默认为０
  　　　字符串则表示进程退出时打印内容

六．孤儿和僵尸
１．孤儿进程：父进程先于子进程退出，此时子进程成为孤儿进程．
  特点：孤儿进程会被系统进程收养，此时系统进程就会成为孤儿进程新的父进程．

２．僵尸进程：子进程先于父进程退出，父进程没有处理子进程的退出状态，
　　此时子进程就会成为僵尸进程．
  特点：僵尸进程瑞然已经结束，但是会存留部分信息在PCB中，大量的僵尸进程
  　　会浪费系统内存资源．

３．如何避免僵尸进程的产生
　［１］使用wait函数处理子进程退出状态．
　　　　pid,status = os.wait()
　　功能：父进程中阻塞等待处理子进程的退出
　　返回值：pid 退出的子进程的PID号
　　　　　　status 子进程退出状态

  ［2］使用waitpid函数处理子进程退出状态．
　　　　pid,status = os.waitpid(pid,option)
　　功能：父进程中阻塞等待处理子进程的退出
　　参数：pid -1 表示等待任意子进程退出
　　　　　　　＞0　表示等待指定的子进程退出
　　　　　option 0　 　　表示阻塞等待
　　　　　　　　WNOHANG 表示非阻塞
　　返回值：pid 退出的子进程的PID号
　　　　　　status 子进程退出状态

    -创建二级子进程处理僵尸
　     　－父进程创建子进程，等待回收
　     　－子进程创建二级子进程后立即退出
　     　－二级子进程成为孤儿，和原父进程一同执行事件
　　［3］通过信号处理子进程退出
　　原理：子进程退出时会由操作系统给父进程发送信号，如果
　　　　　父进程忽略这个信号则子进程的退出由操作系统自动处理．
　　方法：使用signal模块忽略信号
　　　import signal
     signal.signal(signal.SIGCHLD,signal.SIG_IGN)
     
     ＊在父进程中添加如上语句，则该父进程所有的子进程退出均由操作系统处理．

七．群聊聊天室
|确定需求－－＞整体设计（确定技术点，模块，结构）－－＞功能分析－－＞代码实现－－＞基本测试
１．功能：类似qq群聊功能
　[1] 有人进入聊天室需要输入姓名，姓名不能重复
　[1] 有人进入聊天室，其他人会收到通知
　　　　xxx　进入了聊天室
　[1] 一个人发消息，其他人会收到消息
　　　xxx : xxxxxxxx
　[1] 有人退出了聊天群，其他人也会收到通知
　　　xxx 退出了聊天室
　[1] 扩展功能：服务端消息公告，服务端发送消息所有人都能收到

２．确定技术模型
　[1] 服务端和客户端，服务端处理请求，发送管理员消息，客户端执行各种功能；
　[1] 套接字选择：UDP套接字
　[1] 消息发送模型：转发
　　　客户端－－＞服务端－－＞其他客户端
　[1] 存储用户信息　{姓名：addr}
　[1] 处理收发关系：多进程分别处理收发

３．注意事项
　[1] 设计封装方法
　[1] 写一个功能模块，测试一个模块
　[1] 注意注释的添加

４．具体实现流程
　[1] 搭建网络模型
　[1] 进入聊天室
    1.客户端：＊输入姓名
    　　　　　 ＊发送给服务器
             ＊接收服务器反馈
             ＊不允许则重新输入，允许则进入聊天室
             ＊创建新的进程用于消息收发
    ２．服务端：＊接收姓名
    　　　　　　＊判断是否允许进入
    　　　　　　＊将结果反馈给客户端
    　　　　　　＊如果不允许则结束，允许将用户插入数据结构
    　　　　　　＊给其他人发送通知
　[1] 聊天
    1.客户端：＊循环发送消息
    　　　　　＊循环接收消息
    2.服务端：＊接收消息，判断消息类型
    　　　　　＊将消息转发
　[1] 退出聊天室
　[1] 管理员消息

作业：将现有聊天室代码整理，